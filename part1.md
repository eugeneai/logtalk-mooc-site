# Logtalk MOOC

(Онлайн-курс по объектно-ориентированному логическому программированию с использованием языка программирования Logtalk)

**Часть 1**

# Лекция 1: Фундаментальные основы логического программирования

## Аннотация

Это онлайн-курс по функциональному программированию с использованием языка программирования Logtalk. Занимайтесь его изучением в удобном для вас темпе. Все материалы и упражнения находятся в открытом доступе.

Курс предназначен для начинающих, которые намереваются изучить логическое программирование на языке Prolog, включая его объектно-ориентированный вариант Logtalk, а также для тех, кто уже имеет опыт работы в области логического программирования и хочет изучить Prolog и Logtalk подробнее. Курс не предполагает никаких предварительных знаний, но хотя бы один язык программирования уже может в некоторой степени облегчить задачу.

Работа с упражнениями предполагает владение командной строкой и базовыми навыками работы с системой контроля версий Git.

Это первая часть курса, состоящего из двух частей. В первой части рассматриваются фундаментальные основы логического программирования, синтаксис и возможности языков Prolog и Logtalk. Вы узнаете основания логической формализации, правила, их структуру, представление рекурсии, типы структуры данных, объекты Logtalk и инструментарий их задания, а также другие возможности логического программирования. В первой части мы будем решать условно "простые" задачи, может быть не имеющие прямого отношения к практике. Во второй части рассматриваются приемы программирования, практические задачи, а также демонстрируются перспективы реализации решений некоторых научных проблем в информатике.

Первая часть разбита на 10 лекций. Они примерно одинаковы по объему, но в некоторых лекциях материала больше, чем в других. Каждая лекция заканчивается 10-12 небольшими упражнениями по программированию по теме лекции.

## Книги и другие ресурсы для чтения

В дополнение к материалам курса следующие источники могут быть полезны, если вы чувствуете, что недостаточно примеров или не все ясно из материалов лекций.

    * Собственно [данный курс](https://logtalk.icc.ru/mdwiki.html#!index.md).
    * Канал Телеграм
    * Репозиторий на сайте github.com
    * Дополнительные ресурсы 
      * И. Братко "Язык программирования Prolog для искусственного интеллекта"
      * ...
## Язык программирования Prolog

В языке программирования Prolog используется следующая терминология:

**Декларативное программирование** - парадигма программирования, точнее класс парадигм, в которых программа описывает **что** такое результат ее работы, **что** мы хотим получить, а не **процесс получения** этого результата. "Вычислительный" процесс организуется системой программирования и специальными механизмами. *Логическое программирование* и *функциональное программирование* являются классическими представителями декларативной парадигмы программирования.

**Логическая** парадигма программирования - программа представляет собой теорию, описывающую предметную область. Основными строительными блоками логической программы являются *утверждения*. Задача программы - доказать, что заданный запрос (утверждение) является истинным. 

**Утверждения** выражаются в одной из следующих форм: *факт*, *правило* или *запрос*. Факты представляют утверждения, истинность которых задана *a priori* (скажем, до начала исполнения программы). Правила логически связывают истинность одних утверждений с другими. Запросы - это утверждения, истинность которых надо доказать.

**Логический вывод** - механизм поиска доказательства, реализованный в системах программирования Prolog, позволяет получать заключения об истинности конкретных запросов. Теоретической базой логического вывода в Prolog является метод резолюции Дж. Робинсона. Системы Prolog могут реализовывать дополнительные модификации стандартной стратегии Линейной резолюции, направленные на решение специальных задач.

**Побочные эффекты** - механизм обеспечения "связи" теории с практикой. При построении логического вывода (исполнении программы), программа может взаимодействовать с файлами, пользователем, другими программами и процессами при помощи специальных встроенных *предикатов*.

**Предикаты** - это, по сути, спецификации утверждений в программах и библиотеках Prolog, аналогично тому, как это делается в других языках. Этимология слова "предикат" восходит к латинскому языку (*predicatum*), и обозначает "свойство", "упомянутое", "заявленное", "сказанное". В лингвистике предикатом обозначают сказуемое, которым, как правило, выступает глагол. Так как предикат задает "сигнатуру" утверждения, то он либо истинный, либо ложный, либо его истинность не может быть определена. Истинность предиката зависит от набора его "аргументов".

**Термы** - структуры языка, обозначающие некоторый **объект**. В отличие от предикатов, которые только истинные, ложные, не истинные и не ложные, терм обозначает (указывает на) объект предметной области. Терм - это либо константа, либо переменная, либо сложный терм с аргументами. В качестве аргументов выступают другие термы. Термы также являются аргументами предикатов. Предикаты не могут быть аргументами предикатов и термов, за исключением специальных случаев, рассмотренных в последних лекциях данного раздела.

**Слабая типизация** стандарта ISO-Prolog выражается тем, что аргументами предикатов и термов могут быть любые другие термы. Это одновременно и плохо и хорошо. Плохо - невозможно скомпилировать любую программу; хорошо - программа короткая, не требуется реализовывать систему типов в среде программирования, так называемое обобщающее программирование реализуется само собой в программе.

**Рекурсия** - форма представления повторяющегося процесса при помощи вызова самого себя. По правде говоря, в логическом программировании *рекурсия* несколько условна. Ее имеет смысл рассматривать как вариант реализации механизмом логического вывода доказательство истинности предиката. То есть, правило, в теле которого упоминается его же предикат можно интерпретировать и не как рекурсию.

**Сборка мусора** - механизм удаления ненужных объектов из памяти выполняющейся Prolog-программы. Программисту нет необходимости реализовать выделение памяти под используемые объекты, а также удаление этих объектов. Как в большинстве современных средах программирования, в Prolog удаление автоматическое. Данный момент необходимо учитывать при реализации программы - память может переполниться.

В ходе этого курса на практике разберетесь, что означают все эти термины. Не волнуйтесь, если сейчас некоторые из них звучат весьма абстрактно.

Смотрите также: Страница Wiki о логическом и функциональном программировании.

## Язык программирования Logtalk

**Объединение логики и объектно-ориентированного программирования**. Logtalk объединяет основные преимущества нескольких парадигм программирования - логической, объектно-ориентированной и событийной. С одной стороны, объектная ориентация позволяет нам работать с одним и тем же набором сущностей на разных этапах разработки приложения, давая нам способ организации и инкапсуляции знаний о каждой сущности в рамках определенного домена. С другой стороны, логическое программирование позволяет нам декларативно представлять знания, которые у нас есть о каждой сущности. Вместе эти две парадигмы позволяют нам сократить дистанцию между конкретным приложением и его предметной областью, делая разработку и сопровождение программ более простыми и продуктивными.

С прагматической точки зрения, объекты Logtalk предоставляют возможность определения в Prolog нескольких пространств имен, вместо традиционной для Prolog единой базы данных, что позволяет удовлетворить некоторые потребности крупных программных проектов.

**Интеграция событийно-управляемого и объектно-ориентированного программирования**. Событийно-ориентированное программирование позволяет создавать реактивные системы,
где вычисления, происходящие в каждый момент времени, являются результатом
наблюдений за происходящими событиями. Эта интеграция дополняет
объектно-ориентированное программирование, в котором каждое вычисление инициируется
явной посылкой сообщения объекту. При этом пользователь динамически
определяет, какие события необходимо наблюдать, и устанавливает мониторы для
этих событий. Такая возможность особенно полезна при представлении
взаимодействия между объектами, где необходимо формализовать ограничения на состояния
объектов - участников взаимодействия. 

Предикаты могут быть неявно
вызываться при наступлении события, являющегося предметом наблюдения, что позволяет программировать решения
которые минимизируют связь между объектами. Кроме того, события обеспечивают поддержку
поведенческой рефлексии и могут быть использованы для реализации концепций
*точки* и *советы*, встречающиеся в аспектно-ориентированном программировании.

**Поддержка программирования на основе компонентов** Предикаты можно инкапсулировать внутри *категорий*, которые затем импортируются любым объектом без дублирования кода и независимо от
иерархии объектов. Категория - это объект первого класса инкапсуляции
на том же уровне, что и объекты и протоколы, ее можно использовать
как компонент при создании новых объектов. Таким образом, объекты могут быть
определяться через композицию категорий, которые выступают в качестве мелкозернистых
единиц повторного использования кода. Категории также могут расширять существующие объекты.
Категориями можно воспользоваться для реализации *миксинов* и *аспектов*.
Категории позволяют повторно использовать код между несвязанными объектами,
независимо от иерархических отношений, подобно тому, как протоколы
позволяют повторно использовать интерфейсы.

**Поддержка систем, основанных как на прототипах, так и на классах** Почти все (если не все) существующие сегодня объектно-ориентированные языки основаны либо на классах, либо на прототипах, с сильным преобладанием языков, основанных на классах. Logtalk поддерживает оба типа иерархии. То есть в одном и том же приложении можно использовать иерархии прототипов и классов. Прототипы решают проблему систем, основанных на классах, когда нам иногда приходится определять класс, который будет иметь только один экземпляр. Классы решают двойную проблему систем, основанных на прототипах, когда невозможно инкапсулировать некоторый код для повторного использования другими объектами, но не инкапсулирующим объектом. Автономные объекты, то есть объекты, не принадлежащие к какой-либо иерархии, являются удобным решением для инкапсуляции кода, который будет повторно использоваться несколькими несвязанными объектами.

**Поддержка множества иерархий объектов** Языки Smalltalk-80, Objective-C и Java определяют единую иерархию, уходящую корнями в класс, обычно называемый ``Object``. Это позволяет легко обеспечить общее поведение всех объектов, но также имеет тенденцию приводить к длинным иерархиям, в которых трудно выразить объекты, представляющие собой исключения из стандартного поведения. В Logtalk возможно существование нескольких независимых иерархий объектов. Некоторые из них могут быть основаны на прототипах, а другие - на классах. Кроме того, отдельные объекты обеспечивают простой способ инкапсуляции служебных предикатов, которые не нуждаются в иерархии объектов или не вписываются в нее.

**Разделение между интерфейсом и реализацией** Это ожидаемая (скажем, стандартная) особенность почти любого современного языка программирования. Logtalk обеспечивает поддержку гибкого разделения интерфейса и реализации: директивы предикатов могут быть включены в объект, категорию или протокол (сущности первого порядка в Logtalk) или могут быть распределены среди объектов, категорий и протоколов.

**Приватное, защищенное и открытое наследование** Logtalk поддерживает приватное, защищённое и открытое наследование аналогично C++, позволяя нам ограничивать области видимости наследуемых, импортируемых или реализуемых предикатов (по умолчанию наследование является открытым).

**Предикаты приватных, защищенных и открытых объектов** Logtalk поддерживает сокрытие данных, реализуя предикаты приватных, защищенных и открытых объектов, подобно C++. Приватные предикаты могут быть вызваны только из объекта-контейнера. Защищенные предикаты могут быть вызваны объектом-контейнером или его потомками. Открытые предикаты могут быть вызваны из любого объекта.

**Параметрические объекты** Имена объектов могут быть составными терминами (вместо атомов), что обеспечивает возможность параметризации объектных предикатов. Доступ к значениям параметров осуществляется через встроенный метод вместо того, чтобы задавать область видимости параметров глобальным для всего объекта. Параметрические объекты позволяют рассматривать любую предикатную конструкцию как определяющую *экземпляр* этого параметрического объекта. Таким образом, параметрический объект позволяет нам инкапсулировать и ассоциировать любое количество предикатов с составным термином.

**Совместимость с большинством систем Prolog и стандартом ISO** Система Logtalk разработана таким образом, чтобы быть совместимой с большинством компиляторов Prolog и, в частности, со стандартом ISO Prolog. Она работает практически в любой компьютерной системе с современным компилятором Prolog.
